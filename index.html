<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Anomaly Simulation</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        /* 1:1 Kutu Ayarı - Ekranın %90'ını kaplar ama kare kalır */
        #portal-container {
            width: 90vmin;
            height: 90vmin;
            position: relative;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            filter: contrast(1.5) brightness(1.2);
        }

        /* Eski TV / CRT Efekti için katman */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.4) 50%,
                rgba(0,0,0,0.4)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* Subliminal gürültü efekti */
        .noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 11;
        }
    </style>
</head>
<body>

    <div id="portal-container">
        <div class="scanlines"></div>
        <div class="noise"></div>
        <canvas id="dimensionCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('dimensionCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas çözünürlüğünü ayarla
        let size = 800;
        canvas.width = size;
        canvas.height = size;

        // 4D Nokta Sınıfı
        class P4 {
            constructor(x, y, z, w) {
                this.x = x; this.y = y; this.z = z; this.w = w;
            }
        }

        // Tesseract (Hiperküp) Köşeleri (16 adet)
        let points = [];
        for (let i = 0; i < 16; i++) {
            let x = (i & 1) ? 1 : -1;
            let y = (i & 2) ? 1 : -1;
            let z = (i & 4) ? 1 : -1;
            let w = (i & 8) ? 1 : -1;
            points.push(new P4(x, y, z, w));
        }

        // Açılar
        let angle = 0;
        
        // Rastgelelik ve Kaos değişkenleri
        let chaosMode = false;
        let glitchIntensity = 0;
        let speed = 0.02;
        let colorHue = 0;

        // Projeksiyon Matris Fonksiyonları
        function matMul(m, p) {
            // Basit matris çarpımı (4D rotasyonlar için özelleştirilmiş)
            // Bu örnekte doğrudan rotasyon formülleri kullanacağız
        }

        function draw() {
            // Ekranı temizle ama hafif iz bırak (motion blur etkisi)
            ctx.fillStyle = chaosMode ? 'rgba(20, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, size, size);

            // Rastgele tetiklenen kaos modu
            if (Math.random() < 0.01) chaosMode = !chaosMode;
            if (Math.random() < 0.05) speed = (Math.random() * 0.1) - 0.02; // Hız aniden değişir
            
            // Subliminal titreme
            if (Math.random() < 0.02) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, size, size);
            }

            // Dönüş açılarını güncelle
            angle += speed;
            if (chaosMode) angle += 0.1;

            // 4D Projeksiyon Hesaplamaları
            let projectedPoints = [];

            for (let i = 0; i < points.length; i++) {
                let p = points[i];
                
                // Kopyasını al
                let x = p.x, y = p.y, z = p.z, w = p.w;

                // 4. Boyutta Dönüş (ZW ve XW düzlemleri - en kafa karıştırıcı olanlar)
                // ZW Rotasyonu
                let rw = w * Math.cos(angle) - z * Math.sin(angle);
                let rz = w * Math.sin(angle) + z * Math.cos(angle);
                w = rw; z = rz;

                // XW Rotasyonu (Kaos modunda değişir)
                if (chaosMode || Math.random() < 0.1) {
                    let rx = x * Math.cos(angle * 0.5) - w * Math.sin(angle * 0.5);
                    rw = x * Math.sin(angle * 0.5) + w * Math.cos(angle * 0.5);
                    x = rx; w = rw;
                }

                // 4D -> 3D Projeksiyon
                let distance = 3; // Kamera mesafesi
                let wInv = 1 / (distance - w);
                
                let p3x = x * wInv;
                let p3y = y * wInv;
                let p3z = z * wInv;

                // 3D Rotasyonu (Klasik küp dönüşü)
                let r3x = p3x * Math.cos(angle) - p3z * Math.sin(angle);
                let r3z = p3x * Math.sin(angle) + p3z * Math.cos(angle);
                p3x = r3x; p3z = r3z;

                // 3D -> 2D Projeksiyon
                let zInv = 1 / (distance - p3z);
                let p2x = p3x * zInv;
                let p2y = p3y * zInv;

                // Glitch: Koordinatları rastgele boz
                if (Math.random() < glitchIntensity) {
                    p2x += (Math.random() - 0.5) * 0.5;
                    p2y += (Math.random() - 0.5) * 0.5;
                }

                // Ekrana ölçekle
                let scale = size / 3;
                projectedPoints[i] = {
                    x: p2x * scale + size / 2,
                    y: p2y * scale + size / 2
                };
            }

            // Çizgileri Çiz
            ctx.lineWidth = chaosMode ? 3 : 1.5;
            colorHue = (colorHue + 1) % 360;
            
            // Renk paleti: Genelde yeşil/beyaz, kaos anında kırmızı/mor
            let strokeColor = chaosMode 
                ? `hsl(${Math.random() * 360}, 100%, 50%)` 
                : `hsl(120, 0%, ${Math.random() * 50 + 50}%)`;

            ctx.strokeStyle = strokeColor;

            // Köşeleri bağla
            connectPoints(0, 1, projectedPoints);
            connectPoints(1, 3, projectedPoints);
            connectPoints(3, 2, projectedPoints);
            connectPoints(2, 0, projectedPoints);

            connectPoints(4, 5, projectedPoints);
            connectPoints(5, 7, projectedPoints);
            connectPoints(7, 6, projectedPoints);
            connectPoints(6, 4, projectedPoints);

            connectPoints(0, 4, projectedPoints);
            connectPoints(1, 5, projectedPoints);
            connectPoints(2, 6, projectedPoints);
            connectPoints(3, 7, projectedPoints);

            // İç küp bağlantıları (Tesseract yapısı)
            for(let i=0; i<8; i++) {
                connectPoints(i, i+8, projectedPoints);
            }

            connectPoints(8, 9, projectedPoints);
            connectPoints(9, 11, projectedPoints);
            connectPoints(11, 10, projectedPoints);
            connectPoints(10, 8, projectedPoints);

            connectPoints(12, 13, projectedPoints);
            connectPoints(13, 15, projectedPoints);
            connectPoints(15, 14, projectedPoints);
            connectPoints(14, 12, projectedPoints);

            connectPoints(8, 12, projectedPoints);
            connectPoints(9, 13, projectedPoints);
            connectPoints(10, 14, projectedPoints);
            connectPoints(11, 15, projectedPoints);

            // Glitch yoğunluğunu kontrol et
            if (Math.random() < 0.05) glitchIntensity = 0.1;
            else glitchIntensity = 0;

            requestAnimationFrame(draw);
        }

        function connectPoints(i, j, points) {
            // Bazen çizgileri çizme (Bozukluk hissi için)
            if (Math.random() > 0.98) return;

            ctx.beginPath();
            ctx.moveTo(points[i].x, points[i].y);
            ctx.lineTo(points[j].x, points[j].y);
            ctx.stroke();
        }

        // Loop'u başlat
        draw();

        // Pencere yeniden boyutlandırma
        window.addEventListener('resize', () => {
             // CSS hallediyor ama canvas içeriği resetlenmesin diye burası boş kalabilir
             // veya dinamik scale eklenebilir. Şimdilik CSS container yeterli.
        });

    </script>
</body>
</html>
